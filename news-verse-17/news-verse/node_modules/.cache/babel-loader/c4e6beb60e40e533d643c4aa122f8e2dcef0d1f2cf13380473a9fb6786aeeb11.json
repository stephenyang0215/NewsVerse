{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nexport default {\n  props: {\n    imageSrc: String\n  },\n  data() {\n    return {\n      img: null,\n      mainSelection: {\n        x: 50,\n        y: 50,\n        width: 100,\n        height: 100,\n        children: []\n      },\n      isResizing: false,\n      resizeCorner: null,\n      controlSize: 8\n    };\n  },\n  watch: {\n    imageSrc(newSrc) {\n      if (newSrc) {\n        this.loadImage(newSrc);\n      }\n    }\n  },\n  methods: {\n    loadImage(src) {\n      this.img = new Image();\n      this.img.onload = this.setCanvasAndSelection;\n      this.img.src = src;\n    },\n    setCanvasAndSelection() {\n      const canvas = this.$refs.canvas;\n      canvas.width = this.img.width;\n      canvas.height = this.img.height;\n\n      // 初始化选区\n      this.mainSelection = {\n        x: this.img.width * 0.25,\n        y: this.img.height * 0.25,\n        width: this.img.width * 0.5,\n        height: this.img.height * 0.5\n      };\n      this.drawCanvas();\n    },\n    drawCanvas() {\n      const canvas = this.$refs.canvas;\n      const ctx = canvas.getContext(\"2d\");\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      if (this.img) {\n        ctx.drawImage(this.img, 0, 0);\n      }\n\n      // 绘制灰色遮罩层\n      this.drawOverlay(ctx);\n\n      // // 绘制选区\n      // ctx.strokeStyle = \"red\";\n      // ctx.lineWidth = 2;\n      // ctx.strokeRect(\n      //   this.mainSelection.x,\n      //   this.mainSelection.y,\n      //   this.mainSelection.width,\n      //   this.mainSelection.height\n      // );\n\n      // // 绘制控制点\n      // this.drawControlPoints(ctx);\n\n      // 绘制父选区和子区域\n      this.drawSelection(ctx, this.mainSelection);\n    },\n    // 绘制父选区和子区域\n    drawSelection(ctx, selection) {\n      ctx.strokeStyle = \"red\";\n      ctx.lineWidth = 2;\n      ctx.strokeRect(selection.x, selection.y, selection.width, selection.height);\n\n      // 绘制子区域\n      selection.children.forEach((child, childIndex) => {\n        console.log(childIndex);\n        ctx.strokeStyle = \"green\";\n        ctx.lineWidth = 2;\n        ctx.strokeRect(child.x, child.y, child.width, child.height);\n        this.drawControlPoints(ctx, child, true); // 绘制子区域控制点\n      });\n\n      // 绘制父选区的控制点\n      this.drawControlPoints(ctx, selection);\n    },\n    // 绘制灰色遮罩层\n    drawOverlay(ctx) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = this.mainSelection;\n      ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\"; // 半透明的灰色\n      ctx.fillRect(0, 0, ctx.canvas.width, y); // 选区上方\n      ctx.fillRect(0, y + height, ctx.canvas.width, ctx.canvas.height - (y + height)); // 选区下方\n      ctx.fillRect(0, y, x, height); // 选区左侧\n      ctx.fillRect(x + width, y, ctx.canvas.width - (x + width), height); // 选区右侧\n    },\n    drawControlPoints(ctx) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = this.mainSelection;\n      const controlPoints = [{\n        x: x,\n        y: y\n      }, {\n        x: x + width,\n        y: y\n      }, {\n        x: x,\n        y: y + height\n      }, {\n        x: x + width,\n        y: y + height\n      }];\n      ctx.fillStyle = \"blue\";\n      controlPoints.forEach(point => {\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, this.controlSize / 2, 0, 2 * Math.PI);\n        ctx.fill();\n      });\n    },\n    onMouseDown(event) {\n      const canvasRect = this.$refs.canvas.getBoundingClientRect();\n      const x = event.clientX - canvasRect.left;\n      const y = event.clientY - canvasRect.top;\n\n      // 检查是否点击在子区域内\n      const clickedChildIndex = this.getClickedChildIndex(x, y);\n      if (clickedChildIndex !== null) {\n        // 操作现有的子区域\n        this.activeChildIndex = clickedChildIndex;\n        const clickedCorner = this.getClickedCorner(x, y, this.mainSelection.children[this.activeChildIndex]);\n        if (clickedCorner !== null) {\n          this.isResizing = true;\n          this.resizeCorner = clickedCorner;\n        }\n      } else if (this.isWithinMainSelection(x, y)) {\n        // 在父选区内创建新的子区域\n        this.mainSelection.children.push({\n          x: x,\n          y: y,\n          width: 50,\n          height: 50\n        });\n        this.drawCanvas();\n      }\n    },\n    onMouseUp() {\n      this.isResizing = false;\n      this.resizeCorner = null;\n    },\n    getClickedCorner(x, y) {\n      const {\n        x: selX,\n        y: selY,\n        width,\n        height\n      } = this.mainSelection;\n      const corners = [{\n        x: selX,\n        y: selY\n      }, {\n        x: selX + width,\n        y: selY\n      }, {\n        x: selX,\n        y: selY + height\n      }, {\n        x: selX + width,\n        y: selY + height\n      }];\n      return corners.findIndex(corner => Math.abs(corner.x - x) < this.controlSize && Math.abs(corner.y - y) < this.controlSize);\n    },\n    resizeSelection(x, y) {\n      const {\n        x: selX,\n        y: selY\n      } = this.mainSelection;\n      switch (this.resizeCorner) {\n        case 0:\n          // 左上角\n          this.mainSelection.width += this.mainSelection.x - x;\n          this.mainSelection.height += this.mainSelection.y - y;\n          this.mainSelection.x = x;\n          this.mainSelection.y = y;\n          break;\n        case 1:\n          // 右上角\n          this.mainSelection.width = x - selX;\n          this.mainSelection.height += selY - y;\n          this.mainSelection.y = y;\n          break;\n        case 2:\n          // 左下角\n          this.mainSelection.width += selX - x;\n          this.mainSelection.height = y - selY;\n          this.mainSelection.x = x;\n          break;\n        case 3:\n          // 右下角\n          this.mainSelection.width = x - selX;\n          this.mainSelection.height = y - selY;\n          break;\n      }\n\n      // 限制最小尺寸\n      this.mainSelection.width = Math.max(20, this.mainSelection.width);\n      this.mainSelection.height = Math.max(20, this.mainSelection.height);\n    },\n    sendSelection() {\n      const selectionData = {\n        x: this.mainSelection.x,\n        y: this.mainSelection.y,\n        width: this.mainSelection.width,\n        height: this.mainSelection.height\n      };\n      this.$emit(\"sendSelection\", selectionData);\n    }\n  },\n  mounted() {\n    if (this.imageSrc) {\n      this.loadImage(this.imageSrc);\n    }\n  }\n};","map":{"version":3,"names":["props","imageSrc","String","data","img","mainSelection","x","y","width","height","children","isResizing","resizeCorner","controlSize","watch","newSrc","loadImage","methods","src","Image","onload","setCanvasAndSelection","canvas","$refs","drawCanvas","ctx","getContext","clearRect","drawImage","drawOverlay","drawSelection","selection","strokeStyle","lineWidth","strokeRect","forEach","child","childIndex","console","log","drawControlPoints","fillStyle","fillRect","controlPoints","point","beginPath","arc","Math","PI","fill","onMouseDown","event","canvasRect","getBoundingClientRect","clientX","left","clientY","top","clickedChildIndex","getClickedChildIndex","activeChildIndex","clickedCorner","getClickedCorner","isWithinMainSelection","push","onMouseUp","selX","selY","corners","findIndex","corner","abs","resizeSelection","max","sendSelection","selectionData","$emit","mounted"],"sources":["src/components/CanvasTest.vue"],"sourcesContent":["<template>\n  <div class=\"image-cropper\">\n    <canvas\n      ref=\"canvas\"\n      @mousedown=\"onMouseDown\"\n      @mouseup=\"onMouseUp\"\n      @mousemove=\"onMouseMove\"\n    ></canvas>\n    <button @click=\"sendSelection\">发送选中范围</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    imageSrc: String,\n  },\n  data() {\n    return {\n      img: null,\n      mainSelection: { x: 50, y: 50, width: 100, height: 100, children: [] },\n      isResizing: false,\n      resizeCorner: null,\n      controlSize: 8,\n    };\n  },\n  watch: {\n    imageSrc(newSrc) {\n      if (newSrc) {\n        this.loadImage(newSrc);\n      }\n    },\n  },\n  methods: {\n    loadImage(src) {\n      this.img = new Image();\n      this.img.onload = this.setCanvasAndSelection;\n      this.img.src = src;\n    },\n\n    setCanvasAndSelection() {\n      const canvas = this.$refs.canvas;\n      canvas.width = this.img.width;\n      canvas.height = this.img.height;\n\n      // 初始化选区\n      this.mainSelection = {\n        x: this.img.width * 0.25,\n        y: this.img.height * 0.25,\n        width: this.img.width * 0.5,\n        height: this.img.height * 0.5,\n      };\n\n      this.drawCanvas();\n    },\n\n    drawCanvas() {\n      const canvas = this.$refs.canvas;\n      const ctx = canvas.getContext(\"2d\");\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      if (this.img) {\n        ctx.drawImage(this.img, 0, 0);\n      }\n\n      // 绘制灰色遮罩层\n      this.drawOverlay(ctx);\n\n      // // 绘制选区\n      // ctx.strokeStyle = \"red\";\n      // ctx.lineWidth = 2;\n      // ctx.strokeRect(\n      //   this.mainSelection.x,\n      //   this.mainSelection.y,\n      //   this.mainSelection.width,\n      //   this.mainSelection.height\n      // );\n\n      // // 绘制控制点\n      // this.drawControlPoints(ctx);\n\n      // 绘制父选区和子区域\n      this.drawSelection(ctx, this.mainSelection);\n    },\n\n    // 绘制父选区和子区域\n    drawSelection(ctx, selection) {\n      ctx.strokeStyle = \"red\";\n      ctx.lineWidth = 2;\n      ctx.strokeRect(\n        selection.x,\n        selection.y,\n        selection.width,\n        selection.height\n      );\n\n      // 绘制子区域\n      selection.children.forEach((child, childIndex) => {\n        console.log(childIndex);\n\n        ctx.strokeStyle = \"green\";\n        ctx.lineWidth = 2;\n        ctx.strokeRect(child.x, child.y, child.width, child.height);\n        this.drawControlPoints(ctx, child, true); // 绘制子区域控制点\n      });\n\n      // 绘制父选区的控制点\n      this.drawControlPoints(ctx, selection);\n    },\n\n    // 绘制灰色遮罩层\n    drawOverlay(ctx) {\n      const { x, y, width, height } = this.mainSelection;\n      ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\"; // 半透明的灰色\n      ctx.fillRect(0, 0, ctx.canvas.width, y); // 选区上方\n      ctx.fillRect(\n        0,\n        y + height,\n        ctx.canvas.width,\n        ctx.canvas.height - (y + height)\n      ); // 选区下方\n      ctx.fillRect(0, y, x, height); // 选区左侧\n      ctx.fillRect(x + width, y, ctx.canvas.width - (x + width), height); // 选区右侧\n    },\n\n    drawControlPoints(ctx) {\n      const { x, y, width, height } = this.mainSelection;\n      const controlPoints = [\n        { x: x, y: y },\n        { x: x + width, y: y },\n        { x: x, y: y + height },\n        { x: x + width, y: y + height },\n      ];\n\n      ctx.fillStyle = \"blue\";\n      controlPoints.forEach((point) => {\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, this.controlSize / 2, 0, 2 * Math.PI);\n        ctx.fill();\n      });\n    },\n\n    onMouseDown(event) {\n      const canvasRect = this.$refs.canvas.getBoundingClientRect();\n      const x = event.clientX - canvasRect.left;\n      const y = event.clientY - canvasRect.top;\n\n      // 检查是否点击在子区域内\n      const clickedChildIndex = this.getClickedChildIndex(x, y);\n\n      if (clickedChildIndex !== null) {\n        // 操作现有的子区域\n        this.activeChildIndex = clickedChildIndex;\n        const clickedCorner = this.getClickedCorner(\n          x,\n          y,\n          this.mainSelection.children[this.activeChildIndex]\n        );\n        if (clickedCorner !== null) {\n          this.isResizing = true;\n          this.resizeCorner = clickedCorner;\n        }\n      } else if (this.isWithinMainSelection(x, y)) {\n        // 在父选区内创建新的子区域\n        this.mainSelection.children.push({\n          x: x,\n          y: y,\n          width: 50,\n          height: 50,\n        });\n        this.drawCanvas();\n      }\n    },\n\n    onMouseUp() {\n      this.isResizing = false;\n      this.resizeCorner = null;\n    },\n\n    getClickedCorner(x, y) {\n      const { x: selX, y: selY, width, height } = this.mainSelection;\n      const corners = [\n        { x: selX, y: selY },\n        { x: selX + width, y: selY },\n        { x: selX, y: selY + height },\n        { x: selX + width, y: selY + height },\n      ];\n\n      return corners.findIndex(\n        (corner) =>\n          Math.abs(corner.x - x) < this.controlSize &&\n          Math.abs(corner.y - y) < this.controlSize\n      );\n    },\n\n    resizeSelection(x, y) {\n      const { x: selX, y: selY } = this.mainSelection;\n      switch (this.resizeCorner) {\n        case 0: // 左上角\n          this.mainSelection.width += this.mainSelection.x - x;\n          this.mainSelection.height += this.mainSelection.y - y;\n          this.mainSelection.x = x;\n          this.mainSelection.y = y;\n          break;\n        case 1: // 右上角\n          this.mainSelection.width = x - selX;\n          this.mainSelection.height += selY - y;\n          this.mainSelection.y = y;\n          break;\n        case 2: // 左下角\n          this.mainSelection.width += selX - x;\n          this.mainSelection.height = y - selY;\n          this.mainSelection.x = x;\n          break;\n        case 3: // 右下角\n          this.mainSelection.width = x - selX;\n          this.mainSelection.height = y - selY;\n          break;\n      }\n\n      // 限制最小尺寸\n      this.mainSelection.width = Math.max(20, this.mainSelection.width);\n      this.mainSelection.height = Math.max(20, this.mainSelection.height);\n    },\n\n    sendSelection() {\n      const selectionData = {\n        x: this.mainSelection.x,\n        y: this.mainSelection.y,\n        width: this.mainSelection.width,\n        height: this.mainSelection.height,\n      };\n      this.$emit(\"sendSelection\", selectionData);\n    },\n  },\n  mounted() {\n    if (this.imageSrc) {\n      this.loadImage(this.imageSrc);\n    }\n  },\n};\n</script>\n\n<style scoped>\n.image-cropper {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\ncanvas {\n  border: 1px solid #000;\n  margin-top: 10px;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}