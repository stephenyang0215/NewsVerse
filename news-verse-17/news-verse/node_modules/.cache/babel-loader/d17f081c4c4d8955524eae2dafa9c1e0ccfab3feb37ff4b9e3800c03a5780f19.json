{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nexport default {\n  data() {\n    return {\n      canvasWidth: 0,\n      canvasHeight: 0,\n      image: new Image(),\n      selection: [],\n      // 存储已选择的区域\n      largeSelection: null,\n      // 存储大区域的位置信息\n      isDrawing: false,\n      // 标记是否正在绘制\n      startX: 0,\n      startY: 0,\n      ctx: null,\n      // 画布上下文\n      isInLargeSelection: false // 标记是否在大区域内\n    };\n  },\n  mounted() {\n    this.ctx = this.$refs.canvas.getContext(\"2d\");\n    this.image.src = this.imageSrc || \"\"; // 可以通过props传入图片路径\n    this.image.onload = this.onImageLoad;\n  },\n  props: {\n    imageSrc: {\n      type: String,\n      required: true\n    },\n    // 用于接收后端传来的选区数据\n    initialSelections: {\n      type: Array,\n      default: () => []\n    }\n  },\n  methods: {\n    // 图片加载完毕后设置画布尺寸\n    onImageLoad() {\n      this.canvasWidth = this.image.width;\n      this.canvasHeight = this.image.height;\n      this.ctx.drawImage(this.image, 0, 0); // 绘制图片到画布\n      // this.drawExistingSelections(); // 回显之前的区域\n    },\n    // 绘制所有已选区域\n    drawExistingSelections() {\n      if (this.initialSelections && this.initialSelections.length > 0) {\n        this.initialSelections.forEach(area => {\n          this.selection.push(area);\n        });\n        this.clearCanvas();\n        this.ctx.drawImage(this.image, 0, 0);\n        this.selection.forEach(area => {\n          this.ctx.strokeStyle = \"blue\";\n          this.ctx.lineWidth = 2;\n          this.ctx.strokeRect(area.x, area.y, area.width, area.height);\n        });\n      }\n    },\n    // 开始绘制选区\n    startDrawing(e) {\n      const rect = this.$refs.canvas.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n\n      // 如果点击的是大区域内，允许绘制小区域\n      if (this.largeSelection && this.isInsideLargeSelection(x, y)) {\n        this.isInLargeSelection = true;\n        this.startX = x;\n        this.startY = y;\n        this.isDrawing = true;\n      }\n    },\n    // 绘制选区\n    draw(e) {\n      if (!this.isDrawing) return;\n      const rect = this.$refs.canvas.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n      const width = x - this.startX;\n      const height = y - this.startY;\n      this.clearCanvas();\n      this.ctx.drawImage(this.image, 0, 0);\n\n      // 绘制大区域\n      if (this.largeSelection) {\n        this.ctx.strokeStyle = \"green\";\n        this.ctx.lineWidth = 2;\n        this.ctx.strokeRect(this.largeSelection.x, this.largeSelection.y, this.largeSelection.width, this.largeSelection.height);\n      }\n\n      // 绘制当前的小区域\n      if (this.isInLargeSelection) {\n        this.ctx.strokeStyle = \"red\";\n        this.ctx.lineWidth = 2;\n        this.ctx.strokeRect(this.startX, this.startY, width, height);\n      }\n\n      // 绘制之前已经选择的小区域\n      this.selection.forEach(area => {\n        this.ctx.strokeStyle = \"blue\";\n        this.ctx.lineWidth = 2;\n        this.ctx.strokeRect(area.x, area.y, area.width, area.height);\n      });\n    },\n    // 完成绘制选区\n    endDrawing(e) {\n      if (!this.isDrawing) return;\n      const rect = this.$refs.canvas.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n      if (this.isInLargeSelection && this.largeSelection) {\n        const width = x - this.startX;\n        const height = y - this.startY;\n        this.selection.push({\n          x: this.startX,\n          y: this.startY,\n          width: width,\n          height: height\n        });\n        this.isDrawing = false;\n        this.isInLargeSelection = false;\n\n        // 清空画布并重新绘制所有区域\n        this.clearCanvas();\n        this.ctx.drawImage(this.image, 0, 0);\n        this.ctx.strokeStyle = \"green\";\n        this.ctx.lineWidth = 2;\n        this.ctx.strokeRect(this.largeSelection.x, this.largeSelection.y, this.largeSelection.width, this.largeSelection.height);\n        this.selection.forEach(area => {\n          this.ctx.strokeStyle = \"blue\";\n          this.ctx.lineWidth = 2;\n          this.ctx.strokeRect(area.x, area.y, area.width, area.height);\n        });\n      }\n    },\n    // 检查是否在大区域内\n    isInsideLargeSelection(x, y) {\n      if (this.largeSelection && x >= this.largeSelection.x && y >= this.largeSelection.y && x <= this.largeSelection.x + this.largeSelection.width && y <= this.largeSelection.y + this.largeSelection.height) {\n        return true;\n      }\n      return false;\n    },\n    // 清空画布\n    clearCanvas() {\n      this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n    },\n    // 保存选中的区域\n    saveSelections() {\n      // 可以根据需要将数据发送到后端\n      const selectionData = this.selection;\n      console.log(\"保存选中的区域:\", selectionData);\n\n      // 假设你发送到后端的 API:\n      // axios.post('/api/save-selection', { selections: selectionData })\n      //   .then(response => {\n      //     console.log('保存成功');\n      //   })\n      //   .catch(error => {\n      //     console.error('保存失败', error);\n      //   });\n    },\n    // 设置大区域（初次加载时或从后端回显数据时调用）\n    setLargeSelection(x, y, width, height) {\n      this.largeSelection = {\n        x,\n        y,\n        width,\n        height\n      };\n      this.clearCanvas();\n      this.ctx.drawImage(this.image, 0, 0);\n      this.ctx.strokeStyle = \"green\";\n      this.ctx.lineWidth = 2;\n      this.ctx.strokeRect(x, y, width, height);\n    }\n  }\n};","map":{"version":3,"names":["data","canvasWidth","canvasHeight","image","Image","selection","largeSelection","isDrawing","startX","startY","ctx","isInLargeSelection","mounted","$refs","canvas","getContext","src","imageSrc","onload","onImageLoad","props","type","String","required","initialSelections","Array","default","methods","width","height","drawImage","drawExistingSelections","length","forEach","area","push","clearCanvas","strokeStyle","lineWidth","strokeRect","x","y","startDrawing","e","rect","getBoundingClientRect","clientX","left","clientY","top","isInsideLargeSelection","draw","endDrawing","clearRect","saveSelections","selectionData","console","log","setLargeSelection"],"sources":["src/components/ImageSelection.vue"],"sourcesContent":["<template>\n  <div>\n    <canvas\n      ref=\"canvas\"\n      :width=\"canvasWidth\"\n      :height=\"canvasHeight\"\n      @mousedown=\"startDrawing\"\n      @mousemove=\"draw\"\n      @mouseup=\"endDrawing\"\n      @mouseleave=\"endDrawing\"\n      class=\"canvas\"\n    ></canvas>\n    <button @click=\"saveSelections\">保存选区</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      canvasWidth: 0,\n      canvasHeight: 0,\n      image: new Image(),\n      selection: [], // 存储已选择的区域\n      largeSelection: null, // 存储大区域的位置信息\n      isDrawing: false, // 标记是否正在绘制\n      startX: 0,\n      startY: 0,\n      ctx: null, // 画布上下文\n      isInLargeSelection: false, // 标记是否在大区域内\n    };\n  },\n  mounted() {\n    this.ctx = this.$refs.canvas.getContext(\"2d\");\n    this.image.src = this.imageSrc || \"\"; // 可以通过props传入图片路径\n    this.image.onload = this.onImageLoad;\n  },\n  props: {\n    imageSrc: {\n      type: String,\n      required: true,\n    },\n    // 用于接收后端传来的选区数据\n    initialSelections: {\n      type: Array,\n      default: () => [],\n    },\n  },\n  methods: {\n    // 图片加载完毕后设置画布尺寸\n    onImageLoad() {\n      this.canvasWidth = this.image.width;\n      this.canvasHeight = this.image.height;\n      this.ctx.drawImage(this.image, 0, 0); // 绘制图片到画布\n      // this.drawExistingSelections(); // 回显之前的区域\n    },\n\n    // 绘制所有已选区域\n    drawExistingSelections() {\n      if (this.initialSelections && this.initialSelections.length > 0) {\n        this.initialSelections.forEach((area) => {\n          this.selection.push(area);\n        });\n        this.clearCanvas();\n        this.ctx.drawImage(this.image, 0, 0);\n        this.selection.forEach((area) => {\n          this.ctx.strokeStyle = \"blue\";\n          this.ctx.lineWidth = 2;\n          this.ctx.strokeRect(area.x, area.y, area.width, area.height);\n        });\n      }\n    },\n\n    // 开始绘制选区\n    startDrawing(e) {\n      const rect = this.$refs.canvas.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n\n      // 如果点击的是大区域内，允许绘制小区域\n      if (this.largeSelection && this.isInsideLargeSelection(x, y)) {\n        this.isInLargeSelection = true;\n        this.startX = x;\n        this.startY = y;\n        this.isDrawing = true;\n      }\n    },\n\n    // 绘制选区\n    draw(e) {\n      if (!this.isDrawing) return;\n      const rect = this.$refs.canvas.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n\n      const width = x - this.startX;\n      const height = y - this.startY;\n\n      this.clearCanvas();\n      this.ctx.drawImage(this.image, 0, 0);\n\n      // 绘制大区域\n      if (this.largeSelection) {\n        this.ctx.strokeStyle = \"green\";\n        this.ctx.lineWidth = 2;\n        this.ctx.strokeRect(\n          this.largeSelection.x,\n          this.largeSelection.y,\n          this.largeSelection.width,\n          this.largeSelection.height\n        );\n      }\n\n      // 绘制当前的小区域\n      if (this.isInLargeSelection) {\n        this.ctx.strokeStyle = \"red\";\n        this.ctx.lineWidth = 2;\n        this.ctx.strokeRect(this.startX, this.startY, width, height);\n      }\n\n      // 绘制之前已经选择的小区域\n      this.selection.forEach((area) => {\n        this.ctx.strokeStyle = \"blue\";\n        this.ctx.lineWidth = 2;\n        this.ctx.strokeRect(area.x, area.y, area.width, area.height);\n      });\n    },\n\n    // 完成绘制选区\n    endDrawing(e) {\n      if (!this.isDrawing) return;\n      const rect = this.$refs.canvas.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n\n      if (this.isInLargeSelection && this.largeSelection) {\n        const width = x - this.startX;\n        const height = y - this.startY;\n\n        this.selection.push({\n          x: this.startX,\n          y: this.startY,\n          width: width,\n          height: height,\n        });\n\n        this.isDrawing = false;\n        this.isInLargeSelection = false;\n\n        // 清空画布并重新绘制所有区域\n        this.clearCanvas();\n        this.ctx.drawImage(this.image, 0, 0);\n        this.ctx.strokeStyle = \"green\";\n        this.ctx.lineWidth = 2;\n        this.ctx.strokeRect(\n          this.largeSelection.x,\n          this.largeSelection.y,\n          this.largeSelection.width,\n          this.largeSelection.height\n        );\n        this.selection.forEach((area) => {\n          this.ctx.strokeStyle = \"blue\";\n          this.ctx.lineWidth = 2;\n          this.ctx.strokeRect(area.x, area.y, area.width, area.height);\n        });\n      }\n    },\n\n    // 检查是否在大区域内\n    isInsideLargeSelection(x, y) {\n      if (\n        this.largeSelection &&\n        x >= this.largeSelection.x &&\n        y >= this.largeSelection.y &&\n        x <= this.largeSelection.x + this.largeSelection.width &&\n        y <= this.largeSelection.y + this.largeSelection.height\n      ) {\n        return true;\n      }\n      return false;\n    },\n\n    // 清空画布\n    clearCanvas() {\n      this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n    },\n\n    // 保存选中的区域\n    saveSelections() {\n      // 可以根据需要将数据发送到后端\n      const selectionData = this.selection;\n      console.log(\"保存选中的区域:\", selectionData);\n\n      // 假设你发送到后端的 API:\n      // axios.post('/api/save-selection', { selections: selectionData })\n      //   .then(response => {\n      //     console.log('保存成功');\n      //   })\n      //   .catch(error => {\n      //     console.error('保存失败', error);\n      //   });\n    },\n\n    // 设置大区域（初次加载时或从后端回显数据时调用）\n    setLargeSelection(x, y, width, height) {\n      this.largeSelection = { x, y, width, height };\n      this.clearCanvas();\n      this.ctx.drawImage(this.image, 0, 0);\n      this.ctx.strokeStyle = \"green\";\n      this.ctx.lineWidth = 2;\n      this.ctx.strokeRect(x, y, width, height);\n    },\n  },\n};\n</script>\n\n<style scoped>\ncanvas {\n  border: 1px solid #000;\n  cursor: crosshair;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}