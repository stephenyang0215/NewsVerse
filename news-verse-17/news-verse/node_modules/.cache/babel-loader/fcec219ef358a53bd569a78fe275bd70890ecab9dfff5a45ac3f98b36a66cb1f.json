{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nexport default {\n  props: {\n    imageSrc: String // 从父组件传入的图片源\n  },\n  data() {\n    return {\n      img: new Image(),\n      // 用于加载图片\n      selection: {\n        x: 50,\n        y: 50,\n        width: 100,\n        height: 100,\n        children: []\n      },\n      // 初始选区\n      isResizing: false,\n      // 是否正在调整选区大小\n      resizeCorner: null,\n      // 当前被拖拽的控制点\n      controlSize: 8,\n      // 控制点的大小\n      ctx: null,\n      // Canvas 上下文\n      startX: 0,\n      // 鼠标按下时的 X 坐标\n      startY: 0 // 鼠标按下时的 Y 坐标\n    };\n  },\n  watch: {\n    imageSrc(newSrc) {\n      if (newSrc) {\n        this.loadImage(newSrc); // 监听 imageSrc 变化，重新加载图片\n      }\n    }\n  },\n  methods: {\n    // 加载图片并初始化 canvas\n    loadImage(src) {\n      this.img.onload = this.setCanvasAndSelection; // 图片加载完成后设置 canvas\n      this.img.src = src; // 设置图片源\n    },\n    // 设置 canvas 的尺寸和初始选区\n    setCanvasAndSelection() {\n      const canvas = this.$refs.canvas;\n      canvas.width = this.img.width; // 设置 canvas 宽度\n      canvas.height = this.img.height; // 设置 canvas 高度\n\n      // 初始化选区为图片的 50% 大小\n      this.selection = {\n        x: this.img.width * 0.25,\n        y: this.img.height * 0.25,\n        width: this.img.width * 0.5,\n        height: this.img.height * 0.5,\n        children: []\n      };\n      this.drawCanvas(); // 初始绘制\n    },\n    // 绘制 Canvas 内容\n    drawCanvas() {\n      // 清空 canvas，重新绘制图片和选区\n      this.ctx.clearRect(0, 0, this.$refs.canvas.width, this.$refs.canvas.height);\n      if (this.img) {\n        this.ctx.drawImage(this.img, 0, 0); // 绘制图片\n      }\n\n      // 绘制遮罩层\n      this.drawOverlay();\n\n      // 绘制当前选区\n      this.ctx.strokeStyle = \"red\";\n      this.ctx.lineWidth = 2;\n      this.ctx.strokeRect(this.selection.x, this.selection.y, this.selection.width, this.selection.height);\n\n      // 绘制已选区\n      this.selection.children.forEach(area => {\n        this.ctx.strokeRect(area.x, area.y, area.width, area.height);\n      });\n\n      // 绘制控制点\n      this.drawControlPoints();\n    },\n    // 绘制遮罩层\n    drawOverlay() {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = this.selection;\n      const ctx = this.ctx;\n\n      // 半透明的灰色遮罩\n      ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n      // 遮罩上下左右区域，除了选区外\n      ctx.fillRect(0, 0, ctx.canvas.width, y); // 上\n      ctx.fillRect(0, y + height, ctx.canvas.width, ctx.canvas.height - (y + height)); // 下\n      ctx.fillRect(0, y, x, height); // 左\n      ctx.fillRect(x + width, y, ctx.canvas.width - (x + width), height); // 右\n    },\n    // 绘制控制点\n    drawControlPoints() {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = this.selection;\n      const controlPoints = [{\n        x: x,\n        y: y\n      },\n      // 左上角\n      {\n        x: x + width,\n        y: y\n      },\n      // 右上角\n      {\n        x: x,\n        y: y + height\n      },\n      // 左下角\n      {\n        x: x + width,\n        y: y + height\n      } // 右下角\n      ];\n      this.ctx.fillStyle = \"blue\";\n      controlPoints.forEach(point => {\n        this.ctx.beginPath();\n        this.ctx.arc(point.x, point.y, this.controlSize / 2, 0, 2 * Math.PI); // 绘制圆形控制点\n        this.ctx.fill();\n      });\n    },\n    // 鼠标按下事件\n    onMouseDown(event) {\n      const canvasRect = this.$refs.canvas.getBoundingClientRect();\n      this.startX = event.clientX - canvasRect.left;\n      this.startY = event.clientY - canvasRect.top;\n\n      // 检查是否点击了控制点\n      const clickedCorner = this.getClickedCorner(this.startX, this.startY);\n      if (clickedCorner !== null) {\n        this.isResizing = true; // 开始调整选区大小\n        this.resizeCorner = clickedCorner; // 设置当前操作的控制点\n      }\n    },\n    // 鼠标移动事件\n    onMouseMove(event) {\n      if (!this.isResizing) return; // 只有在调整大小时才执行\n\n      const canvasRect = this.$refs.canvas.getBoundingClientRect();\n      const x = event.clientX - canvasRect.left;\n      const y = event.clientY - canvasRect.top;\n\n      // 调整选区大小\n      if (this.resizeCorner !== null) {\n        this.resizeSelection(x, y);\n      } else {\n        const width = x - this.startX;\n        const height = y - this.startY;\n        this.drawCanvas(width, height);\n      }\n    },\n    // 鼠标松开事件\n    onMouseUp() {\n      if (this.resizeCorner !== null) {\n        this.isResizing = false; // 结束调整大小\n        this.resizeCorner = null; // 清空当前操作的控制点\n      } else {\n        // 记录选区的坐标和大小\n        const {\n          x,\n          y,\n          width,\n          height\n        } = this.selection;\n        this.selection.children.push({\n          x,\n          y,\n          width,\n          height\n        });\n      }\n\n      // 重新绘制所有选区和当前选区\n      this.drawCanvas();\n    },\n    // 判断鼠标点击是否在控制点上\n    getClickedCorner(x, y) {\n      const {\n        x: selX,\n        y: selY,\n        width,\n        height\n      } = this.selection;\n      const corners = [{\n        x: selX,\n        y: selY\n      }, {\n        x: selX + width,\n        y: selY\n      }, {\n        x: selX,\n        y: selY + height\n      }, {\n        x: selX + width,\n        y: selY + height\n      }];\n      return corners.findIndex(corner => Math.abs(corner.x - x) < this.controlSize && Math.abs(corner.y - y) < this.controlSize);\n    },\n    // 调整选区大小\n    resizeSelection(x, y) {\n      const {\n        x: selX,\n        y: selY\n      } = this.selection;\n      switch (this.resizeCorner) {\n        case 0:\n          // 左上角\n          this.selection.width += this.selection.x - x;\n          this.selection.height += this.selection.y - y;\n          this.selection.x = x;\n          this.selection.y = y;\n          break;\n        case 1:\n          // 右上角\n          this.selection.width = x - selX;\n          this.selection.height += selY - y;\n          this.selection.y = y;\n          break;\n        case 2:\n          // 左下角\n          this.selection.width += selX - x;\n          this.selection.height = y - selY;\n          this.selection.x = x;\n          break;\n        case 3:\n          // 右下角\n          this.selection.width = x - selX;\n          this.selection.height = y - selY;\n          break;\n      }\n\n      // 限制最小尺寸为 20px\n      this.selection.width = Math.max(20, this.selection.width);\n      this.selection.height = Math.max(20, this.selection.height);\n    },\n    // 发送选区数据\n    sendSelection() {\n      const selectionData = {\n        x: this.selection.x,\n        y: this.selection.y,\n        width: this.selection.width,\n        height: this.selection.height\n      };\n      this.$emit(\"sendSelection\", selectionData); // 向父组件发送选区数据\n    }\n  },\n  mounted() {\n    this.ctx = this.$refs.canvas.getContext(\"2d\"); // 获取 canvas 上下文\n    if (this.imageSrc) {\n      this.loadImage(this.imageSrc); // 如果传入了图片源，加载图片\n    }\n  }\n};","map":{"version":3,"names":["props","imageSrc","String","data","img","Image","selection","x","y","width","height","children","isResizing","resizeCorner","controlSize","ctx","startX","startY","watch","newSrc","loadImage","methods","src","onload","setCanvasAndSelection","canvas","$refs","drawCanvas","clearRect","drawImage","drawOverlay","strokeStyle","lineWidth","strokeRect","forEach","area","drawControlPoints","fillStyle","fillRect","controlPoints","point","beginPath","arc","Math","PI","fill","onMouseDown","event","canvasRect","getBoundingClientRect","clientX","left","clientY","top","clickedCorner","getClickedCorner","onMouseMove","resizeSelection","onMouseUp","push","selX","selY","corners","findIndex","corner","abs","max","sendSelection","selectionData","$emit","mounted","getContext"],"sources":["src/components/CanvasTest.vue"],"sourcesContent":["<template>\n  <div class=\"image-cropper\">\n    <!-- Canvas 元素，用于展示和裁剪图像 -->\n    <canvas\n      ref=\"canvas\"\n      @mousedown=\"onMouseDown\"\n      @mouseup=\"onMouseUp\"\n      @mousemove=\"onMouseMove\"\n    ></canvas>\n\n    <!-- 发送选区数据按钮 -->\n    <button @click=\"sendSelection\">发送选中范围</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    imageSrc: String, // 从父组件传入的图片源\n  },\n  data() {\n    return {\n      img: new Image(), // 用于加载图片\n      selection: { x: 50, y: 50, width: 100, height: 100, children: [] }, // 初始选区\n      isResizing: false, // 是否正在调整选区大小\n      resizeCorner: null, // 当前被拖拽的控制点\n      controlSize: 8, // 控制点的大小\n      ctx: null, // Canvas 上下文\n      startX: 0, // 鼠标按下时的 X 坐标\n      startY: 0, // 鼠标按下时的 Y 坐标\n    };\n  },\n  watch: {\n    imageSrc(newSrc) {\n      if (newSrc) {\n        this.loadImage(newSrc); // 监听 imageSrc 变化，重新加载图片\n      }\n    },\n  },\n  methods: {\n    // 加载图片并初始化 canvas\n    loadImage(src) {\n      this.img.onload = this.setCanvasAndSelection; // 图片加载完成后设置 canvas\n      this.img.src = src; // 设置图片源\n    },\n\n    // 设置 canvas 的尺寸和初始选区\n    setCanvasAndSelection() {\n      const canvas = this.$refs.canvas;\n      canvas.width = this.img.width; // 设置 canvas 宽度\n      canvas.height = this.img.height; // 设置 canvas 高度\n\n      // 初始化选区为图片的 50% 大小\n      this.selection = {\n        x: this.img.width * 0.25,\n        y: this.img.height * 0.25,\n        width: this.img.width * 0.5,\n        height: this.img.height * 0.5,\n        children: [],\n      };\n\n      this.drawCanvas(); // 初始绘制\n    },\n\n    // 绘制 Canvas 内容\n    drawCanvas() {\n      // 清空 canvas，重新绘制图片和选区\n      this.ctx.clearRect(\n        0,\n        0,\n        this.$refs.canvas.width,\n        this.$refs.canvas.height\n      );\n\n      if (this.img) {\n        this.ctx.drawImage(this.img, 0, 0); // 绘制图片\n      }\n\n      // 绘制遮罩层\n      this.drawOverlay();\n\n      // 绘制当前选区\n      this.ctx.strokeStyle = \"red\";\n      this.ctx.lineWidth = 2;\n      this.ctx.strokeRect(\n        this.selection.x,\n        this.selection.y,\n        this.selection.width,\n        this.selection.height\n      );\n\n      // 绘制已选区\n      this.selection.children.forEach((area) => {\n        this.ctx.strokeRect(area.x, area.y, area.width, area.height);\n      });\n\n      // 绘制控制点\n      this.drawControlPoints();\n    },\n\n    // 绘制遮罩层\n    drawOverlay() {\n      const { x, y, width, height } = this.selection;\n      const ctx = this.ctx;\n\n      // 半透明的灰色遮罩\n      ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n      // 遮罩上下左右区域，除了选区外\n      ctx.fillRect(0, 0, ctx.canvas.width, y); // 上\n      ctx.fillRect(\n        0,\n        y + height,\n        ctx.canvas.width,\n        ctx.canvas.height - (y + height)\n      ); // 下\n      ctx.fillRect(0, y, x, height); // 左\n      ctx.fillRect(x + width, y, ctx.canvas.width - (x + width), height); // 右\n    },\n\n    // 绘制控制点\n    drawControlPoints() {\n      const { x, y, width, height } = this.selection;\n      const controlPoints = [\n        { x: x, y: y }, // 左上角\n        { x: x + width, y: y }, // 右上角\n        { x: x, y: y + height }, // 左下角\n        { x: x + width, y: y + height }, // 右下角\n      ];\n\n      this.ctx.fillStyle = \"blue\";\n      controlPoints.forEach((point) => {\n        this.ctx.beginPath();\n        this.ctx.arc(point.x, point.y, this.controlSize / 2, 0, 2 * Math.PI); // 绘制圆形控制点\n        this.ctx.fill();\n      });\n    },\n\n    // 鼠标按下事件\n    onMouseDown(event) {\n      const canvasRect = this.$refs.canvas.getBoundingClientRect();\n      this.startX = event.clientX - canvasRect.left;\n      this.startY = event.clientY - canvasRect.top;\n\n      // 检查是否点击了控制点\n      const clickedCorner = this.getClickedCorner(this.startX, this.startY);\n      if (clickedCorner !== null) {\n        this.isResizing = true; // 开始调整选区大小\n        this.resizeCorner = clickedCorner; // 设置当前操作的控制点\n      }\n    },\n\n    // 鼠标移动事件\n    onMouseMove(event) {\n      if (!this.isResizing) return; // 只有在调整大小时才执行\n\n      const canvasRect = this.$refs.canvas.getBoundingClientRect();\n      const x = event.clientX - canvasRect.left;\n      const y = event.clientY - canvasRect.top;\n\n      // 调整选区大小\n      if (this.resizeCorner !== null) {\n        this.resizeSelection(x, y);\n      } else {\n        const width = x - this.startX;\n        const height = y - this.startY;\n        this.drawCanvas(width, height);\n      }\n    },\n\n    // 鼠标松开事件\n    onMouseUp() {\n      if (this.resizeCorner !== null) {\n        this.isResizing = false; // 结束调整大小\n        this.resizeCorner = null; // 清空当前操作的控制点\n      } else {\n        // 记录选区的坐标和大小\n        const { x, y, width, height } = this.selection;\n        this.selection.children.push({ x, y, width, height });\n      }\n\n      // 重新绘制所有选区和当前选区\n      this.drawCanvas();\n    },\n\n    // 判断鼠标点击是否在控制点上\n    getClickedCorner(x, y) {\n      const { x: selX, y: selY, width, height } = this.selection;\n      const corners = [\n        { x: selX, y: selY },\n        { x: selX + width, y: selY },\n        { x: selX, y: selY + height },\n        { x: selX + width, y: selY + height },\n      ];\n\n      return corners.findIndex(\n        (corner) =>\n          Math.abs(corner.x - x) < this.controlSize &&\n          Math.abs(corner.y - y) < this.controlSize\n      );\n    },\n\n    // 调整选区大小\n    resizeSelection(x, y) {\n      const { x: selX, y: selY } = this.selection;\n      switch (this.resizeCorner) {\n        case 0: // 左上角\n          this.selection.width += this.selection.x - x;\n          this.selection.height += this.selection.y - y;\n          this.selection.x = x;\n          this.selection.y = y;\n          break;\n        case 1: // 右上角\n          this.selection.width = x - selX;\n          this.selection.height += selY - y;\n          this.selection.y = y;\n          break;\n        case 2: // 左下角\n          this.selection.width += selX - x;\n          this.selection.height = y - selY;\n          this.selection.x = x;\n          break;\n        case 3: // 右下角\n          this.selection.width = x - selX;\n          this.selection.height = y - selY;\n          break;\n      }\n\n      // 限制最小尺寸为 20px\n      this.selection.width = Math.max(20, this.selection.width);\n      this.selection.height = Math.max(20, this.selection.height);\n    },\n\n    // 发送选区数据\n    sendSelection() {\n      const selectionData = {\n        x: this.selection.x,\n        y: this.selection.y,\n        width: this.selection.width,\n        height: this.selection.height,\n      };\n      this.$emit(\"sendSelection\", selectionData); // 向父组件发送选区数据\n    },\n  },\n  mounted() {\n    this.ctx = this.$refs.canvas.getContext(\"2d\"); // 获取 canvas 上下文\n    if (this.imageSrc) {\n      this.loadImage(this.imageSrc); // 如果传入了图片源，加载图片\n    }\n  },\n};\n</script>\n\n<style scoped>\n.image-cropper {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\ncanvas {\n  border: 1px solid #000;\n  margin-top: 10px;\n}\nbutton {\n  margin-top: 10px;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}