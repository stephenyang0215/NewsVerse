{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nexport default {\n  props: {\n    imageSrc: String\n  },\n  data() {\n    return {\n      img: null,\n      selections: [{\n        x: 50,\n        y: 50,\n        width: 200,\n        height: 150,\n        children: []\n      }],\n      // 父选区和子区域的结构\n      isResizing: false,\n      resizeCorner: null,\n      controlSize: 8,\n      activeSelectionIndex: null,\n      // 当前父选区索引\n      activeChildIndex: null // 当前操作的子区域索引\n    };\n  },\n  watch: {\n    imageSrc(newSrc) {\n      if (newSrc) {\n        this.loadImage(newSrc);\n      }\n    }\n  },\n  methods: {\n    loadImage(src) {\n      this.img = new Image();\n      this.img.onload = this.setCanvasAndSelection;\n      this.img.src = src;\n    },\n    setCanvasAndSelection() {\n      const canvas = this.$refs.canvas;\n      canvas.width = this.img.width;\n      canvas.height = this.img.height;\n      this.drawCanvas();\n    },\n    drawCanvas() {\n      const canvas = this.$refs.canvas;\n      const ctx = canvas.getContext(\"2d\");\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      if (this.img) {\n        ctx.drawImage(this.img, 0, 0);\n      }\n\n      // 绘制灰色遮罩层\n      this.drawOverlay(ctx);\n\n      // 绘制所有选区和子区域\n      this.selections.forEach((selection, index) => {\n        this.drawSelection(ctx, selection, index);\n      });\n    },\n    // 绘制选区和子区域\n    drawSelection(ctx, selection, index) {\n      ctx.strokeStyle = \"red\";\n      ctx.lineWidth = 2;\n      ctx.strokeRect(selection.x, selection.y, selection.width, selection.height);\n\n      // 绘制子区域\n      selection.children.forEach((child, childIndex) => {\n        ctx.strokeStyle = \"green\";\n        ctx.lineWidth = 2;\n        ctx.strokeRect(child.x, child.y, child.width, child.height);\n        this.drawControlPoints(ctx, child, true); // 绘制子区域控制点\n      });\n\n      // 绘制父选区的控制点\n      this.drawControlPoints(ctx, selection);\n    },\n    drawControlPoints(ctx, selection, isChild = false) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = selection;\n      const controlPoints = [{\n        x: x,\n        y: y\n      }, {\n        x: x + width,\n        y: y\n      }, {\n        x: x,\n        y: y + height\n      }, {\n        x: x + width,\n        y: y + height\n      }];\n      ctx.fillStyle = isChild ? \"green\" : \"blue\";\n      controlPoints.forEach(point => {\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, this.controlSize / 2, 0, 2 * Math.PI);\n        ctx.fill();\n      });\n    },\n    drawOverlay(ctx) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = this.selections[0];\n      ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n      ctx.fillRect(0, 0, ctx.canvas.width, y);\n      ctx.fillRect(0, y + height, ctx.canvas.width, ctx.canvas.height - (y + height));\n      ctx.fillRect(0, y, x, height);\n      ctx.fillRect(x + width, y, ctx.canvas.width - (x + width), height);\n    },\n    onMouseDown(event) {\n      const canvasRect = this.$refs.canvas.getBoundingClientRect();\n      const x = event.clientX - canvasRect.left;\n      const y = event.clientY - canvasRect.top;\n\n      // 检查是否点击在现有的父选区或子区域内\n      const clickedSelectionIndex = this.getClickedSelectionIndex(x, y);\n      if (clickedSelectionIndex !== null) {\n        this.activeSelectionIndex = clickedSelectionIndex;\n        const selection = this.selections[this.activeSelectionIndex];\n\n        // 检查是否点击在子区域内\n        const clickedChildIndex = this.getClickedChildIndex(selection, x, y);\n        if (clickedChildIndex !== null) {\n          this.activeChildIndex = clickedChildIndex;\n          const clickedCorner = this.getClickedCorner(x, y, selection.children[this.activeChildIndex]);\n          if (clickedCorner !== null) {\n            this.isResizing = true;\n            this.resizeCorner = clickedCorner;\n          }\n        } else {\n          // 没有点击子区域，则准备在父选区内新增子区域\n          selection.children.push({\n            x: x,\n            y: y,\n            width: 50,\n            height: 50\n          });\n          this.drawCanvas();\n        }\n      }\n    },\n    onMouseMove(event) {\n      if (!this.isResizing) return;\n      const canvasRect = this.$refs.canvas.getBoundingClientRect();\n      const x = event.clientX - canvasRect.left;\n      const y = event.clientY - canvasRect.top;\n\n      // 调整子区域大小\n      this.resizeSelection(x, y, true);\n      this.drawCanvas();\n    },\n    onMouseUp() {\n      this.isResizing = false;\n      this.resizeCorner = null;\n    },\n    getClickedSelectionIndex(x, y) {\n      return this.selections.findIndex(selection => x >= selection.x && x <= selection.x + selection.width && y >= selection.y && y <= selection.y + selection.height);\n    },\n    getClickedChildIndex(selection, x, y) {\n      return selection.children.findIndex(child => x >= child.x && x <= child.x + child.width && y >= child.y && y <= child.y + child.height);\n    },\n    getClickedCorner(x, y, selection) {\n      const {\n        x: selX,\n        y: selY,\n        width,\n        height\n      } = selection;\n      const corners = [{\n        x: selX,\n        y: selY\n      }, {\n        x: selX + width,\n        y: selY\n      }, {\n        x: selX,\n        y: selY + height\n      }, {\n        x: selX + width,\n        y: selY + height\n      }];\n      return corners.findIndex(corner => Math.abs(corner.x - x) < this.controlSize && Math.abs(corner.y - y) < this.controlSize);\n    },\n    resizeSelection(x, y, isChild = false) {\n      const selection = isChild ? this.selections[this.activeSelectionIndex].children[this.activeChildIndex] : this.selections[this.activeSelectionIndex];\n      const {\n        x: selX,\n        y: selY,\n        width,\n        height\n      } = selection;\n      switch (this.resizeCorner) {\n        case 0:\n          selection.width += selX - x;\n          selection.height += selY - y;\n          selection.x = x;\n          selection.y = y;\n          break;\n        case 1:\n          selection.width = x - selX;\n          selection.height += selY - y;\n          selection.y = y;\n          break;\n        case 2:\n          selection.width += selX - x;\n          selection.height = y - selY;\n          selection.x = x;\n          break;\n        case 3:\n          selection.width = x - selX;\n          selection.height = y - selY;\n          break;\n      }\n      selection.width = Math.max(20, selection.width);\n      selection.height = Math.max(20, selection.height);\n    },\n    sendSelection() {\n      const selectionData = this.selections.map(sel => ({\n        x: sel.x,\n        y: sel.y,\n        width: sel.width,\n        height: sel.height,\n        children: sel.children\n      }));\n      this.$emit(\"sendSelection\", selectionData);\n    }\n  },\n  mounted() {\n    if (this.imageSrc) {\n      this.loadImage(this.imageSrc);\n    }\n  }\n};","map":{"version":3,"names":["props","imageSrc","String","data","img","selections","x","y","width","height","children","isResizing","resizeCorner","controlSize","activeSelectionIndex","activeChildIndex","watch","newSrc","loadImage","methods","src","Image","onload","setCanvasAndSelection","canvas","$refs","drawCanvas","ctx","getContext","clearRect","drawImage","drawOverlay","forEach","selection","index","drawSelection","strokeStyle","lineWidth","strokeRect","child","childIndex","drawControlPoints","isChild","controlPoints","fillStyle","point","beginPath","arc","Math","PI","fill","fillRect","onMouseDown","event","canvasRect","getBoundingClientRect","clientX","left","clientY","top","clickedSelectionIndex","getClickedSelectionIndex","clickedChildIndex","getClickedChildIndex","clickedCorner","getClickedCorner","push","onMouseMove","resizeSelection","onMouseUp","findIndex","selX","selY","corners","corner","abs","max","sendSelection","selectionData","map","sel","$emit","mounted"],"sources":["src/components/CanvasTest.vue"],"sourcesContent":["<template>\n  <div class=\"image-cropper\">\n    <canvas\n      ref=\"canvas\"\n      @mousedown=\"onMouseDown\"\n      @mouseup=\"onMouseUp\"\n      @mousemove=\"onMouseMove\"\n    ></canvas>\n    <button @click=\"sendSelection\">发送选中范围</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    imageSrc: String,\n  },\n  data() {\n    return {\n      img: null,\n      selections: [{ x: 50, y: 50, width: 200, height: 150, children: [] }], // 父选区和子区域的结构\n      isResizing: false,\n      resizeCorner: null,\n      controlSize: 8,\n      activeSelectionIndex: null, // 当前父选区索引\n      activeChildIndex: null, // 当前操作的子区域索引\n    };\n  },\n  watch: {\n    imageSrc(newSrc) {\n      if (newSrc) {\n        this.loadImage(newSrc);\n      }\n    },\n  },\n  methods: {\n    loadImage(src) {\n      this.img = new Image();\n      this.img.onload = this.setCanvasAndSelection;\n      this.img.src = src;\n    },\n\n    setCanvasAndSelection() {\n      const canvas = this.$refs.canvas;\n      canvas.width = this.img.width;\n      canvas.height = this.img.height;\n      this.drawCanvas();\n    },\n\n    drawCanvas() {\n      const canvas = this.$refs.canvas;\n      const ctx = canvas.getContext(\"2d\");\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      if (this.img) {\n        ctx.drawImage(this.img, 0, 0);\n      }\n\n      // 绘制灰色遮罩层\n      this.drawOverlay(ctx);\n\n      // 绘制所有选区和子区域\n      this.selections.forEach((selection, index) => {\n        this.drawSelection(ctx, selection, index);\n      });\n    },\n\n    // 绘制选区和子区域\n    drawSelection(ctx, selection, index) {\n      ctx.strokeStyle = \"red\";\n      ctx.lineWidth = 2;\n      ctx.strokeRect(\n        selection.x,\n        selection.y,\n        selection.width,\n        selection.height\n      );\n\n      // 绘制子区域\n      selection.children.forEach((child, childIndex) => {\n        ctx.strokeStyle = \"green\";\n        ctx.lineWidth = 2;\n        ctx.strokeRect(child.x, child.y, child.width, child.height);\n        this.drawControlPoints(ctx, child, true); // 绘制子区域控制点\n      });\n\n      // 绘制父选区的控制点\n      this.drawControlPoints(ctx, selection);\n    },\n\n    drawControlPoints(ctx, selection, isChild = false) {\n      const { x, y, width, height } = selection;\n      const controlPoints = [\n        { x: x, y: y },\n        { x: x + width, y: y },\n        { x: x, y: y + height },\n        { x: x + width, y: y + height },\n      ];\n\n      ctx.fillStyle = isChild ? \"green\" : \"blue\";\n      controlPoints.forEach((point) => {\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, this.controlSize / 2, 0, 2 * Math.PI);\n        ctx.fill();\n      });\n    },\n\n    drawOverlay(ctx) {\n      const { x, y, width, height } = this.selections[0];\n      ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n      ctx.fillRect(0, 0, ctx.canvas.width, y);\n      ctx.fillRect(\n        0,\n        y + height,\n        ctx.canvas.width,\n        ctx.canvas.height - (y + height)\n      );\n      ctx.fillRect(0, y, x, height);\n      ctx.fillRect(x + width, y, ctx.canvas.width - (x + width), height);\n    },\n\n    onMouseDown(event) {\n      const canvasRect = this.$refs.canvas.getBoundingClientRect();\n      const x = event.clientX - canvasRect.left;\n      const y = event.clientY - canvasRect.top;\n\n      // 检查是否点击在现有的父选区或子区域内\n      const clickedSelectionIndex = this.getClickedSelectionIndex(x, y);\n\n      if (clickedSelectionIndex !== null) {\n        this.activeSelectionIndex = clickedSelectionIndex;\n        const selection = this.selections[this.activeSelectionIndex];\n\n        // 检查是否点击在子区域内\n        const clickedChildIndex = this.getClickedChildIndex(selection, x, y);\n\n        if (clickedChildIndex !== null) {\n          this.activeChildIndex = clickedChildIndex;\n          const clickedCorner = this.getClickedCorner(\n            x,\n            y,\n            selection.children[this.activeChildIndex]\n          );\n          if (clickedCorner !== null) {\n            this.isResizing = true;\n            this.resizeCorner = clickedCorner;\n          }\n        } else {\n          // 没有点击子区域，则准备在父选区内新增子区域\n          selection.children.push({\n            x: x,\n            y: y,\n            width: 50,\n            height: 50,\n          });\n          this.drawCanvas();\n        }\n      }\n    },\n\n    onMouseMove(event) {\n      if (!this.isResizing) return;\n\n      const canvasRect = this.$refs.canvas.getBoundingClientRect();\n      const x = event.clientX - canvasRect.left;\n      const y = event.clientY - canvasRect.top;\n\n      // 调整子区域大小\n      this.resizeSelection(x, y, true);\n      this.drawCanvas();\n    },\n\n    onMouseUp() {\n      this.isResizing = false;\n      this.resizeCorner = null;\n    },\n\n    getClickedSelectionIndex(x, y) {\n      return this.selections.findIndex(\n        (selection) =>\n          x >= selection.x &&\n          x <= selection.x + selection.width &&\n          y >= selection.y &&\n          y <= selection.y + selection.height\n      );\n    },\n\n    getClickedChildIndex(selection, x, y) {\n      return selection.children.findIndex(\n        (child) =>\n          x >= child.x &&\n          x <= child.x + child.width &&\n          y >= child.y &&\n          y <= child.y + child.height\n      );\n    },\n\n    getClickedCorner(x, y, selection) {\n      const { x: selX, y: selY, width, height } = selection;\n      const corners = [\n        { x: selX, y: selY },\n        { x: selX + width, y: selY },\n        { x: selX, y: selY + height },\n        { x: selX + width, y: selY + height },\n      ];\n\n      return corners.findIndex(\n        (corner) =>\n          Math.abs(corner.x - x) < this.controlSize &&\n          Math.abs(corner.y - y) < this.controlSize\n      );\n    },\n\n    resizeSelection(x, y, isChild = false) {\n      const selection = isChild\n        ? this.selections[this.activeSelectionIndex].children[\n            this.activeChildIndex\n          ]\n        : this.selections[this.activeSelectionIndex];\n      const { x: selX, y: selY, width, height } = selection;\n\n      switch (this.resizeCorner) {\n        case 0:\n          selection.width += selX - x;\n          selection.height += selY - y;\n          selection.x = x;\n          selection.y = y;\n          break;\n        case 1:\n          selection.width = x - selX;\n          selection.height += selY - y;\n          selection.y = y;\n          break;\n        case 2:\n          selection.width += selX - x;\n          selection.height = y - selY;\n          selection.x = x;\n          break;\n        case 3:\n          selection.width = x - selX;\n          selection.height = y - selY;\n          break;\n      }\n\n      selection.width = Math.max(20, selection.width);\n      selection.height = Math.max(20, selection.height);\n    },\n\n    sendSelection() {\n      const selectionData = this.selections.map((sel) => ({\n        x: sel.x,\n        y: sel.y,\n        width: sel.width,\n        height: sel.height,\n        children: sel.children,\n      }));\n      this.$emit(\"sendSelection\", selectionData);\n    },\n  },\n  mounted() {\n    if (this.imageSrc) {\n      this.loadImage(this.imageSrc);\n    }\n  },\n};\n</script>\n\n<style scoped>\n.image-cropper {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\ncanvas {\n  border: 1px solid #000;\n  margin-top: 10px;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}